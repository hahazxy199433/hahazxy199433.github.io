<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP协议那些事(二) | zxy的前端日志</title>
    <meta name="description" content="大前端之路开启">
    <link rel="icon" href="/blog/react.png">
    
    <link rel="preload" href="/blog/assets/css/0.styles.3b40c6a8.css" as="style"><link rel="preload" href="/blog/assets/js/app.2887e526.js" as="script"><link rel="preload" href="/blog/assets/js/2.7b0ce6ad.js" as="script"><link rel="preload" href="/blog/assets/js/29.7097e34b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ac58ca83.js"><link rel="prefetch" href="/blog/assets/js/11.d822bd7a.js"><link rel="prefetch" href="/blog/assets/js/12.561611ff.js"><link rel="prefetch" href="/blog/assets/js/13.3a9698ac.js"><link rel="prefetch" href="/blog/assets/js/14.deaeefba.js"><link rel="prefetch" href="/blog/assets/js/15.81934279.js"><link rel="prefetch" href="/blog/assets/js/16.999bd877.js"><link rel="prefetch" href="/blog/assets/js/17.0ed379b7.js"><link rel="prefetch" href="/blog/assets/js/18.46b2b0d6.js"><link rel="prefetch" href="/blog/assets/js/19.0944e38f.js"><link rel="prefetch" href="/blog/assets/js/20.286e7ff2.js"><link rel="prefetch" href="/blog/assets/js/21.aa310d13.js"><link rel="prefetch" href="/blog/assets/js/22.57f17596.js"><link rel="prefetch" href="/blog/assets/js/23.c6084c24.js"><link rel="prefetch" href="/blog/assets/js/24.22bb6fac.js"><link rel="prefetch" href="/blog/assets/js/25.bb1dea73.js"><link rel="prefetch" href="/blog/assets/js/26.85ebd835.js"><link rel="prefetch" href="/blog/assets/js/27.2ed9d708.js"><link rel="prefetch" href="/blog/assets/js/28.5571acf3.js"><link rel="prefetch" href="/blog/assets/js/3.2d5e9df6.js"><link rel="prefetch" href="/blog/assets/js/30.75b317a9.js"><link rel="prefetch" href="/blog/assets/js/31.6e709d0a.js"><link rel="prefetch" href="/blog/assets/js/32.6254cc6f.js"><link rel="prefetch" href="/blog/assets/js/33.56612655.js"><link rel="prefetch" href="/blog/assets/js/34.341b20a8.js"><link rel="prefetch" href="/blog/assets/js/35.4238dd74.js"><link rel="prefetch" href="/blog/assets/js/36.b431c8f5.js"><link rel="prefetch" href="/blog/assets/js/37.3c9c478b.js"><link rel="prefetch" href="/blog/assets/js/38.1c87b872.js"><link rel="prefetch" href="/blog/assets/js/39.16bdbf93.js"><link rel="prefetch" href="/blog/assets/js/4.0bad6984.js"><link rel="prefetch" href="/blog/assets/js/40.12c76f53.js"><link rel="prefetch" href="/blog/assets/js/41.5fa63467.js"><link rel="prefetch" href="/blog/assets/js/42.7db641e9.js"><link rel="prefetch" href="/blog/assets/js/43.4a217d14.js"><link rel="prefetch" href="/blog/assets/js/44.320c9f84.js"><link rel="prefetch" href="/blog/assets/js/45.b23bd7ce.js"><link rel="prefetch" href="/blog/assets/js/46.174ab2ac.js"><link rel="prefetch" href="/blog/assets/js/47.c01d821b.js"><link rel="prefetch" href="/blog/assets/js/48.b75fbfe1.js"><link rel="prefetch" href="/blog/assets/js/49.438ab1c4.js"><link rel="prefetch" href="/blog/assets/js/5.bfa31649.js"><link rel="prefetch" href="/blog/assets/js/50.56040266.js"><link rel="prefetch" href="/blog/assets/js/51.29f0bb43.js"><link rel="prefetch" href="/blog/assets/js/52.5f351dc0.js"><link rel="prefetch" href="/blog/assets/js/53.4b60010a.js"><link rel="prefetch" href="/blog/assets/js/54.64b07e1e.js"><link rel="prefetch" href="/blog/assets/js/55.bd1b0e53.js"><link rel="prefetch" href="/blog/assets/js/56.6a6af214.js"><link rel="prefetch" href="/blog/assets/js/57.89dadf8c.js"><link rel="prefetch" href="/blog/assets/js/58.f4b0817a.js"><link rel="prefetch" href="/blog/assets/js/59.87e6fd85.js"><link rel="prefetch" href="/blog/assets/js/6.bd4bec1a.js"><link rel="prefetch" href="/blog/assets/js/60.10fb02cf.js"><link rel="prefetch" href="/blog/assets/js/61.11943b67.js"><link rel="prefetch" href="/blog/assets/js/62.5f0e595c.js"><link rel="prefetch" href="/blog/assets/js/63.b725dcf9.js"><link rel="prefetch" href="/blog/assets/js/64.9c758ae1.js"><link rel="prefetch" href="/blog/assets/js/65.fd7cbffd.js"><link rel="prefetch" href="/blog/assets/js/66.7205ae4d.js"><link rel="prefetch" href="/blog/assets/js/67.ec0b4786.js"><link rel="prefetch" href="/blog/assets/js/68.40657a10.js"><link rel="prefetch" href="/blog/assets/js/69.2e3c8ba3.js"><link rel="prefetch" href="/blog/assets/js/7.d5109915.js"><link rel="prefetch" href="/blog/assets/js/70.55f0731e.js"><link rel="prefetch" href="/blog/assets/js/71.7828f43c.js"><link rel="prefetch" href="/blog/assets/js/72.e7c3d23b.js"><link rel="prefetch" href="/blog/assets/js/73.7f36e706.js"><link rel="prefetch" href="/blog/assets/js/8.52248ecb.js"><link rel="prefetch" href="/blog/assets/js/9.c3e8123a.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.3b40c6a8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">zxy的前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/blog/book/" class="nav-link">阅读</a></div> <a href="https://github.com/zxy/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/blog/book/" class="nav-link">阅读</a></div> <a href="https://github.com/zxy/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework(大佬写的)</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/library-node.html" class="sidebar-link">Node.js 使用总结</a></li><li><a href="/blog/blog/library-react.html" class="sidebar-link">React 使用总结</a></li><li><a href="/blog/blog/libary-react-core.html" class="sidebar-link">React 核心知识</a></li><li><a href="/blog/blog/library-react-code-1.html" class="sidebar-link">React 源码解析（一）JSX 转换</a></li><li><a href="/blog/blog/library-react-code-2.html" class="sidebar-link">React 源码解析（二）FiberRoot 构建</a></li><li><a href="/blog/blog/library-react-code-3.html" class="sidebar-link">React 源码解析（三）Fiber 的调度过程</a></li><li><a href="/blog/blog/library-react-ssr.html" class="sidebar-link">React 服务器端渲染</a></li><li><a href="/blog/blog/library-react-hooks.html" class="sidebar-link">使用 React Hooks 节省 90% 的代码</a></li><li><a href="/blog/blog/library-vue.html" class="sidebar-link">Vue 使用总结</a></li><li><a href="/blog/blog/library-miniProgram.html" class="sidebar-link">小程序使用总结</a></li><li><a href="/blog/blog/library-redux.html" class="sidebar-link">Redux 使用总结</a></li><li><a href="/blog/blog/library-rxjs.html" class="sidebar-link">RxJS 基础知识总结</a></li><li><a href="/blog/blog/libary-koa.html" class="sidebar-link">Koa 源代码阅读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>PHP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-05-28-php.html" class="sidebar-link">PHP学习(一) 基础语法</a></li><li><a href="/blog/blog/2019-06-05-php&amp;mysql.html" class="sidebar-link">PHP学习(二) php与mysql</a></li><li><a href="/blog/blog/2019-06-05-php_OOP_introduction.html" class="sidebar-link">PHP学习(三) php面向对象介绍</a></li><li><a href="/blog/blog/2019-06-05-PHP_construct.html" class="sidebar-link">PHP学习(四) 构造方法和析构方法</a></li><li><a href="/blog/blog/2019-06-10-OOP_fengzhuang.html" class="sidebar-link">PHP学习(五) PHP面向对象之封装性</a></li><li><a href="/blog/blog/2019-06-10-OOP_jicheng_duotai.html" class="sidebar-link">PHP学习(六) PHP面向对象之继承与多态</a></li><li><a href="/blog/blog/2019-06-10-OOP_interface_abstract.html" class="sidebar-link">PHP学习(七) PHP抽象类与接口</a></li><li><a href="/blog/blog/2019-06-11-OPP_error.html" class="sidebar-link">PHP学习(八) PHP异常处理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-06-25-node.html" class="sidebar-link">Node.js学习(基础)</a></li><li><a href="/blog/blog/2019-06-26-express1.html" class="sidebar-link">express学习(一) express介绍</a></li><li><a href="/blog/blog/2019-06-27-express-middleware.html" class="sidebar-link">express学习(二) 中间件</a></li><li><a href="/blog/blog/2019-06-27-express-router.html" class="sidebar-link">express学习(三) 路由</a></li><li><a href="/blog/blog/2019-06-27-express-error.html" class="sidebar-link">express学习(四) 错误处理</a></li><li><a href="/blog/blog/2019-08-19-node.html" class="sidebar-link">大规模NodeJS项目架构与优化</a></li><li><a href="/blog/blog/2019-08-20-express.html" class="sidebar-link">express入门实战</a></li><li><a href="/blog/blog/2019-08-20-node-pachong.html" class="sidebar-link">爬虫</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-06-27-qa.html" class="sidebar-link">Javascript与QA工程师(一)</a></li><li><a href="/blog/blog/2019-08-04-QA.html" class="sidebar-link">Javascript与QA工程师(二)</a></li><li><a href="/blog/blog/2019-07-05-webpack1.html" class="sidebar-link">webpack4学习(一) webpack的核心概念</a></li><li><a href="/blog/blog/2019-07-05-webpack2.html" class="sidebar-link">webpack4学习(二) webpack的高级概念</a></li><li><a href="/blog/blog/2019-07-09-webpack3.html" class="sidebar-link">webpack4学习(三) webpack实战配置</a></li><li><a href="/blog/blog/2019-07-10-webpack4.html" class="sidebar-link">webpack4学习(四) webpack底层原理及脚手架工具分析</a></li><li><a href="/blog/blog/webpack-0-1.html" class="sidebar-link">webpack4 从0到1搭建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/" class="sidebar-link">博客</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-07-31-fp-.html" class="sidebar-link">函数式编程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Linux</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-05-27-Linux-instructions.html" class="sidebar-link">Linux常用指令</a></li><li><a href="/blog/blog/2019-07-31-linux.html" class="sidebar-link">Linux预读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络协议</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/2019-08-14-http1.html" class="sidebar-link">HTTP协议那些事(一)</a></li><li><a href="/blog/blog/2019-08-15-http2.html" class="active sidebar-link">HTTP协议那些事(二)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#密码学入门" class="sidebar-link">密码学入门</a></li><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#https-协议分析" class="sidebar-link">HTTPS 协议分析</a></li><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#http2-协议分析" class="sidebar-link">HTTP2 协议分析</a></li><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#了解-http3" class="sidebar-link">了解 HTTP3</a></li><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#后台服务与-http" class="sidebar-link">后台服务与 HTTP</a></li><li class="sidebar-sub-header"><a href="/blog/blog/2019-08-15-http2.html#反向代理与web服务" class="sidebar-link">反向代理与WEB服务</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码解读</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/react源码1.html" class="sidebar-link">React 源码解读（一）</a></li><li><a href="/blog/blog/react源码2.html" class="sidebar-link">React 源码解读（二） Fiber Root</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http协议那些事-二"><a href="#http协议那些事-二" aria-hidden="true" class="header-anchor">#</a> HTTP协议那些事(二)</h1> <h2 id="密码学入门"><a href="#密码学入门" aria-hidden="true" class="header-anchor">#</a> 密码学入门</h2> <h3 id="密码学入门-2"><a href="#密码学入门-2" aria-hidden="true" class="header-anchor">#</a> 密码学入门</h3> <ul><li><p>密码学的处理对象是数字和字符串。</p></li> <li><p>散列(哈希、md5等)是一种数据一旦转换为其他形式将永远无法恢复的加密技术。</p></li> <li><p>加密</p></li></ul> <ul><li>对称加密（AES、DES、3DES）</li> <li>非对称加密（RSA）</li></ul> <ul><li>密钥交换算法</li></ul> <ul><li>Diffie-Hellman算法是一种著名的密钥协商算法，这种算法可以使得信息交换的双方通过公开的非安 全的网络协商生成安全的共享密钥。</li></ul> <ul><li>（1）Alice与Bob确定两个大素数n和g，这两个数不用保密</li> <li>（2）Alice选择另一个大随机数x，并计算A如下：A=gx mod n</li> <li>（3）Alice将A发给Bob</li> <li>（4）Bob选择另一个大随机数y，并计算B如下：B=gy mod n</li> <li>（5）Bob将B发给Alice</li> <li>（6）计算秘密密钥K1如下：K1=Bx mod n</li> <li>（7）计算秘密密钥K2如下：K2=Ay mod n</li> <li>K1=K2，因此Alice和Bob可以用其进行加解密</li></ul> <h3 id="证书签发机构（ca）"><a href="#证书签发机构（ca）" aria-hidden="true" class="header-anchor">#</a> 证书签发机构（CA）</h3> <ul><li><p>通过CA发放的证书完成密钥的交换，实际上是利用非对称的加密算法完成数据加密密钥 的安全交换，然后再利用数据加密密钥完成数据的安全交换。</p></li> <li><p>数字证书：数字证书是互联网通信中标识双方身份信息的数字文件，由CA签发。 CA：CA（certification authority）是数字证书的签发机构。作为权威机构，其审核申请 者身份后签发数字证书，这样我们只需要校验数字证书即可确定对方的真实身份。</p></li> <li><p>CA的工作流程:</p></li></ul> <ul><li>1.服务器 example.com将从CA请求TLS证书，例如 Digicert。</li> <li>2.Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称， 服务器的公钥等。</li> <li>3.Digicert将创建数据（证书）的哈希值，并使用自己的私钥对其进行加密。</li> <li>4.浏览器和操作系统自带Digicert等权威机构的公钥。</li> <li>5.当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列，如果两个哈希值匹配，则签名验证成 功并且证书是可信的。</li> <li>6.现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。
在这里，我们可以将Digicert称为 Root CA.</li></ul> <h3 id="浏览器如何验证服务器证书的有效性"><a href="#浏览器如何验证服务器证书的有效性" aria-hidden="true" class="header-anchor">#</a> 浏览器如何验证服务器证书的有效性</h3> <ul><li><p>证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工 作，即Digicert，Geotrust，Comodo等。如果他们正在为所有服务器 签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所 有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引 入了中间CA(intermediate CA)的概念。</p></li> <li><p>服务器使用中级证书颁发机构的签名，因此，在与浏览器通信时，服 务器将共享两个证书：</p></li></ul> <ul><li>1.包含服务器的公钥，即实际的服务器证书；</li> <li>2.由 Root CA 颁发的 intermediate CA 证书。</li></ul> <ul><li>在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA的 公钥来验证中间证书的数字签名，如果成功，浏览器现在可以信任中 间证书及其公钥。现在使用此公钥，浏览器将验证原始服务器证书的 签名，该组织可以注册为intermediate CA，以便为其域签署证书。</li></ul> <h3 id="ssl-tls协议"><a href="#ssl-tls协议" aria-hidden="true" class="header-anchor">#</a> SSL/TLS协议</h3> <ul><li><p>传输层安全性协议（Transport Layer Security - TLS），及其前身安全套接层（Secure Sockets Layer - SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p></li> <li><p>HTTPS协议的安全性由SSL协议实现，当前使用的TLS协议 1.2 版本包含了四个核心子协 议：握手协议、密钥配置切换协议、应用数据协议及报警协议。</p></li></ul> <ul><li>TLS适用于对称密钥</li> <li>对称密钥可以通过安全密钥交换算法共享</li> <li>如果请求被截获，密钥交换可能会被欺骗</li> <li>使用数字签名进行身份验证</li> <li>证书颁发机构和信任链。</li></ul> <ul><li>HTTPS协议、SSL协议、TLS协议、握手协议的关系</li></ul> <ul><li>HTTPS是Hypertext Transfer Protocol over Secure Socket Layer的缩写，即HTTP over SSL，可理解为基于SSL的HTTP协议。HTTPS协议安全是由SSL协议实现的。</li> <li>SSL协议是一种记录协议，扩展性良好，可以很方便的添加子协议</li> <li>握手协议是SSL协议的一个子协议。</li> <li>TLS协议是SSL协议的后续版本，本文中涉及的SSL协议默认是TLS协议1.2版本。</li></ul> <h2 id="https-协议分析"><a href="#https-协议分析" aria-hidden="true" class="header-anchor">#</a> HTTPS 协议分析</h2> <p>TLS 握手的步骤：</p> <ol><li>ClientHello：客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给 服务器端。</li> <li>ServerHello：服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法， 返回给客户端。</li> <li>SendCertificate（可选）：服务器端发送服务端证书给客户端。</li> <li>RequestCertificate（可选）：如果选择双向验证，服务器端向客户端请求客户端证书。</li> <li>ServerHelloDone：服务器端通知客户端初始协商结束。</li> <li>ResponseCertificate（可选）：如果选择双向验证，客户端向服务器端发送客户端证书。</li> <li>ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端。</li> <li>CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通 过收到的客户端公钥进行身份验证。</li> <li>CreateSecretKey：通讯双方基于密钥种子等信息生成通讯密钥。</li> <li>ChangeCipherSpec：客户端通知服务器端已将通讯方式切换到加密模式。</li> <li>Finished：客户端做好加密通讯的准备。</li> <li>ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式。</li> <li>Finished：服务器做好加密通讯的准备。</li> <li>Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密。</li> <li>ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息。</li></ol> <h2 id="http2-协议分析"><a href="#http2-协议分析" aria-hidden="true" class="header-anchor">#</a> HTTP2 协议分析</h2> <h3 id="http-2协议分析"><a href="#http-2协议分析" aria-hidden="true" class="header-anchor">#</a> HTTP 2协议分析</h3> <ul><li>HTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标 头字段等核心概念一如往常。</li> <li>HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方 式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。</li> <li>由于HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/ 1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。</li> <li>HTTP2的特点：</li></ul> <ul><li>使用二进制格式传输，更高效、更紧凑。</li> <li>对报头压缩，降低开销。</li> <li>多路复用，一个网络连接实现并行请求。</li> <li>服务器主动推送，减少请求的延迟</li> <li>默认使用加密</li></ul> <h3 id="http-2：二进制分帧层"><a href="#http-2：二进制分帧层" aria-hidden="true" class="header-anchor">#</a> HTTP 2：二进制分帧层</h3> <ul><li>HTTP/2 所有性能增强的核心在于新的二进制分帧 层，它定义了如何封装 HTTP 消息并在客户端与服 务器之间传输。</li> <li>这里所谓的“层”指的是位于套接字接口与应用可见 的高级 HTTP API 之间一个经过优化的新编码机 制。</li> <li>HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和 帧，并采用二进制格式对它们编码。</li> <li>客户端和服务器会替我们完成必要的分帧工作。</li></ul> <h3 id="http-2：多路复用"><a href="#http-2：多路复用" aria-hidden="true" class="header-anchor">#</a> HTTP 2：多路复用</h3> <ul><li>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使 用多个 TCP 连接。这种模型也会导致队首阻塞，从而造成底层 TCP 连接的 效率低下。</li> <li>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 重要的一项增强。这个机制会在整个网络技术栈中引发一系列连锁反 应，从而带来巨大的性能提升。</li></ul> <ul><li>并行交错地发送多个请求，请求之间互不影响。</li> <li>并行交错地发送多个响应，响应之间互不干扰。</li> <li>使用一个连接并行发送多个请求和响应。</li> <li>不必再为绕过 HTTP/1.x 限制而做很多工作</li> <li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时 间。</li></ul> <h3 id="http-2：服务器推送"><a href="#http-2：服务器推送" aria-hidden="true" class="header-anchor">#</a> HTTP 2：服务器推送</h3> <ul><li>HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响 应。 换句话说，除了对初请求的响应外，服务器还可以向客户端推送额外资源， 而无需客户端明确地请求。</li> <li>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流</li> <li>服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</li> <li>推送资源可以进行以下处理：</li></ul> <ul><li>由客户端缓存</li> <li>在不同页面之间重用</li> <li>与其他资源一起复用</li> <li>由服务器设定优先级</li> <li>被客户端拒绝</li></ul> <h3 id="http2的伪头字段"><a href="#http2的伪头字段" aria-hidden="true" class="header-anchor">#</a> HTTP2的伪头字段</h3> <ul><li>伪头部字段是http2内置的几个特殊的以”:”开始的 key，用于替代HTTP/1.x中请求行/响应行中的信 息，比如请求方法，响应状态码等</li></ul> <ul><li>:method 目标URL模式部分（请求）</li> <li>:scheme 目标URL模式部分（请求）</li> <li>:authority 目标RUL认证部分（请求）</li> <li>:path 目标URL的路径和查询部分（绝对路径 产生式和一个跟着&quot;？&quot;字符的查询产生式）。 （请求）</li> <li>:status 响应头中的HTTP状态码部分（响应）</li></ul> <h2 id="了解-http3"><a href="#了解-http3" aria-hidden="true" class="header-anchor">#</a> 了解 HTTP3</h2> <ul><li>运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3（HTTP-over-QUIC）</li> <li>QUIC 协议（Quick UDP Internet Connection）基于 UDP，正是看中了 UDP 的速度与效率。同时 QUIC 也整合了 TCP、TLS 和 HTTP/2 的优 点，并加以优化。</li> <li>特点：</li></ul> <ul><li>减少了握手的延迟（1-RTT 或 0-RTT）</li> <li>多路复用，并且没有 TCP 的阻塞问题</li> <li>连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不 会被断开。</li></ul> <ul><li>HTTP 3与HTTP 1.1和HTTP 2没有直接的关系，也不是http2的扩展</li> <li>HTTP 3将会是一个全新的WEB协议</li> <li>HTTP 3目前处于制订和测试阶段</li> <li>https://www.chromium.org/quic</li></ul> <h2 id="后台服务与-http"><a href="#后台服务与-http" aria-hidden="true" class="header-anchor">#</a> 后台服务与 HTTP</h2> <h3 id="队首阻塞问题"><a href="#队首阻塞问题" aria-hidden="true" class="header-anchor">#</a> 队首阻塞问题</h3> <ul><li>HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking）</li> <li>HTTP/1.1 的队头阻塞。一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样 就浪费了带宽资源。</li> <li>HTTP/2 的多路复用虽然可以解决“请求”这个粒度的阻塞，但 HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题。</li> <li>由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队 头阻塞问题。</li> <li>队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢</li> <li>那 QUIC 解决队头阻塞问题的的方法：</li></ul> <ul><li>QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、 传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题；</li> <li>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</li></ul> <p><img src="/blog/20190815-http2-3.png" alt="图"></p> <h2 id="反向代理与web服务"><a href="#反向代理与web服务" aria-hidden="true" class="header-anchor">#</a> 反向代理与WEB服务</h2> <h3 id="http与反向代理"><a href="#http与反向代理" aria-hidden="true" class="header-anchor">#</a> HTTP与反向代理</h3> <ul><li>什么是代理，什么又是反向代理？</li></ul> <p>正向代理：
代理服务器放在出口。
限制访问权限；
监控访问记录；
作为内网缓存使用；</p> <p>反向代理：
代理服务器放在入口，可以理解为机房
只有一个入口，当客户端想要访问服务器时，需要由入口代理服务器进行反向代理转发到实际服务器上。
可以作为堡垒机使用。</p> <ul><li>为什么要使用反向代理？</li> <li>都有哪些反向代理服务器？</li></ul> <p><img src="/blog/20190815-http2-2.png" alt="图"></p> <h3 id="反向代理的用途"><a href="#反向代理的用途" aria-hidden="true" class="header-anchor">#</a> 反向代理的用途</h3> <ul><li>加密和SSL加速</li> <li>负载均衡</li> <li>缓存静态内容</li> <li>压缩</li> <li>减速上传</li> <li>安全</li> <li>外网发布</li></ul> <h3 id="反向代理做负载均衡"><a href="#反向代理做负载均衡" aria-hidden="true" class="header-anchor">#</a> 反向代理做负载均衡</h3> <p><img src="/blog/20190815-http2-1.png" alt="图"></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/zxy/blog/edit/master/docs/blog/2019-08-15-http2.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新时间: </span> <span class="time">11/5/2019, 2:47:43 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/blog/2019-08-14-http1.html" class="prev">
          HTTP协议那些事(一)
        </a></span> <span class="next"><a href="/blog/blog/react源码1.html">
          React 源码解读（一）
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.2887e526.js" defer></script><script src="/blog/assets/js/2.7b0ce6ad.js" defer></script><script src="/blog/assets/js/29.7097e34b.js" defer></script>
  </body>
</html>
